import java.util.LinkedList;

public class InvAlbum {
    private String name;
    private String condition;
    private InvIndexPhotoManager invmanager;
    private int numberOfComparisons;

    // Constructor
    public InvAlbum(String name, String condition, InvIndexPhotoManager manager) {
        this.name = name;
        this.condition = condition;
        this.invmanager = manager;
        numberOfComparisons = 0;
    }

    // Return the name of the album
    public String getName() {
        return name;
    }

    // Return the condition associated with the album
    public String getCondition() {
        return condition;
    }

    // Return the manager
    public InvIndexPhotoManager getManager() {
        return invmanager;
    }

    // Return all photos that satisfy the album condition
    public LinkedList<Photo> getPhotos() {
        BST<LinkedList<Photo>> photosBST = invmanager.getPhotos();
        LinkedList<Photo> resultPhotos = new LinkedList<Photo>();
        numberOfComparisons = 0;

        String[] tags;
        if (!condition.isEmpty()) {
            tags = condition.split(" AND ");
        } else {
            tags = photosBST.inOrder().split(" AND ");
        }

        for (int i = 0; i < tags.length; i++) {
            if (photosBST.findkey(tags[i])) {
                LinkedList<Photo> tagPhotos = photosBST.retrieve();

                if (i == 0) {
                    // Copy all photos from first tag into resultPhotos
                    tagPhotos.findFirst();
                    do {
                        resultPhotos.insert(tagPhotos.retrieve());
                        if (!tagPhotos.last()) {
                            tagPhotos.findNext();
                        } else {
                            break;
                        }
                    } while (true);
                } else {
                    if (!condition.isEmpty()) {
                        resultPhotos = intersect(resultPhotos, tagPhotos);
                    } else {
                        resultPhotos = union(resultPhotos, tagPhotos);
                    }
                }
            } else {
                resultPhotos = new LinkedList<Photo>();
                break;
            }
        }

        return resultPhotos;
    }

    // Return the number of comparisons
    public int getNbComps() {
        return numberOfComparisons;
    }

    // Check if a photo exists in a list based on its path
    private boolean containsPhoto(LinkedList<Photo> list, Photo targetPhoto) {
        if (list.empty()) return false;

        list.findFirst();
        do {
            numberOfComparisons++;
            if (list.retrieve().getPath().equalsIgnoreCase(targetPhoto.getPath())) {
                return true;
            }
            if (!list.last()) {
                list.findNext();
            } else {
                break;
            }
        } while (true);

        return false;
    }

    // Intersection: only keep photos present in both lists
    private LinkedList<Photo> intersect(LinkedList<Photo> list1, LinkedList<Photo> list2) {
        LinkedList<Photo> result = new LinkedList<Photo>();

        if (!list2.empty()) {
            list2.findFirst();
            do {
                Photo current = list2.retrieve();
                if (containsPhoto(list1, current)) {
                    result.insert(current);
                }

                if (!list2.last()) {
                    list2.findNext();
                } else {
                    break;
                }
            } while (true);
        }

        return result;
    }

    // Union: insert only the photos from list2 not already in list1
    private LinkedList<Photo> union(LinkedList<Photo> list1, LinkedList<Photo> list2) {
        if (!list2.empty()) {
            list2.findFirst();
            do {
                Photo current = list2.retrieve();
                if (!containsPhoto(list1, current)) {
                    list1.insert(current);
                }

                if (!list2.last()) {
                    list2.findNext();
                } else {
                    break;
                }
            } while (true);
        }

        return list1;
    }
}
